# 面向对象

## 概述

## 函数

### 构造函数

### 析构函数

### 拷贝构造函数

## 常函数 静态成员

## 继承

## 聚合与组合

## 虚函数与动态绑定

## 操作符重载

# io库

## 概述

-  std::cin与std::cout相比scanf和printf的优势：
  - scanf、printf 在编译时不进行参数类型检查，会导致与类型相关的运行错误。 而 cin、cout 不需要单独指定数据的类型和个数，编译时刻根据数据本身来决定 操作的类型和个数，这样可以避免与类型和个数相关的错误。
- C++的I/O类库中基本的类及应用场景：
  - 面向控制台的I/O iostream:从标准输入设备（键盘）中获得数据，把程序结果从标准（显示器）输出设备输出。
  - 面向文件的I/O fstream:从外存文件获得数据，把程序结果存到外存文件中。
  - 面向字符串变量的I/O Stringstream:从程序中的字符串变量中获得数据，把程序 结果保存到字符串变量中。

## 重载

- <<>>重载只能是全局函数，不能用成员函数
  - 因为`cout<<c`会被解释成`operator<<(cout, c)`，由于cout在左边，所以不能用成员函数重载

```c++
class A
{		int x,y;
	public:
		......	
		virtual void display(ostream& out) const
		{	out << x << ',' << y ; }
};
ostream& operator << (ostream& out, const A& a)//因为一般不把操作符重载函数做虚函数，因此使用这种方法进行"间接"动态绑定
{	a.display(out); //动态绑定到A类或B类对象的display。
	return out;//方便连续输出cout<<a<<s
}
class B: public A
{		double z;
	public:
		......
		void display(ostream& out) const
		{	A::display(out); out << ',' << z ;   	}
};
A a; B b; A *p=&b;
cout << a << endl << b << endl << *p << endl; //OK
```

## 文件读写

- 每个打开的文件都有一个内部（隐藏）的位置指针，它指出文件的当前读写位置。

  - 进行读/写操作时，每读入/写出一个字节，文件位置指针会自动往后移动一个字节的位置。

- 判断是否正确读入了数据，可以调用ios类的成员函数fail来实现：bool ios::fail() const;

  - 该函数返回true表示文件操作失败；返回false表示操作成功。

- 以二进制方式存取文件不利于程序的兼容性和可移植性。例如，

  - 在不同计算机平台上，整型数的各字节在内存中的存储次序可能不一样。

  - 在不同的编译环境下，同样的结构类型数据的尺寸（字节数）可能不一样。

  - 具有性能优势

- 随机读写：

  - 下面的操作用来指定文件内部读指针的位置：
    - istream& istream::seekg(<位置>)；//指定绝对位置
    - istream& istream::seekg(<偏移量>,<参照位置>); //指定相对位置
    - streampos istream::tellg(); //获得指针位置
  - 下面的操作来指定文件内部写指针的位置：
    - ostream& ostream::seekp(<位置>)；//指定绝对位置
    - ostream& ostream::seekp(<偏移量>,<参照位置>); //指定相对位置
    - streampos ostream::tellp(); //获得指针位置 
  - <参照位置>可以是：ios::beg（文件头），ios::cur（当前位置）和ios::end（文件尾）。

# 异常处理

## 概念

### 错误类型

- 语法错误：违反语法规则，可由编译程序发现。
- 逻辑错误：设计不当造成没有完成预期功能，通过对程序静态分析和动态测试发现。
- 运行异常：程序设计对运行环境考虑不周造成程序运行错误，如内存访问错误等。
  - 可以预见但难以避免，通过对异常进行预见性处理提高程序鲁棒性。

### 异常处理

- 处理策略
  - 就地处理
    - exit：终止程序前，会关闭打开的文件，调用全局对象和static存储类型的局部对象的析构函数。
    - abort：直接终止程序不进行任何处理。
    - 往往在发生地不能很好的处理异常
  - 异地处理
    - 通过返回值返回异常导致正常返回值与异常交叉在一起，有时难以区分
    - 通过指针或引用返回需要引入额外参数
    - 通过全局变量返回可能使用者不知道全局白能量的存在
    - 以上三种方法正常代码与异常处理代码混在一起，可读性差

### 结构化异常处理

- 把有可能出现异常的操作放入try语句块。
  - try{<操作>}如try{f();}
- try中操作出现异常，则通过throw产生一个异常对象，并中断操作的执行。
  - throw <任意类型（类似返回值）>如throw x;
- 异常由catch捕获并处理
  - catch (<类型>[<变量>]){<操作>}
  - 变量名可以缺省，此时只关心类型，不关心值
  - 紧跟在try之后
- 异常的嵌套处理
  - 内层try产生了异常则首先在内层try之后的catch处理，不存在相应的catch则逐步向外查找，如果都找不到系统会进行处理（执行abort）

<img src="../leetcode/media/9异常处理-24.jpg" alt="9异常处理-24" style="zoom: 33%;" />

- 因此函数对外接口出了参数和返回值外增加了可能抛掷的异常

## 断言

- 确认程序运行到某一阶段时的状态是否正，决定是否中断执行
- assert(<表达式>)
  - 表达式为1不进行任何操作
  - 表达式为0输出异常位置，然后执行abort
- 定义了NDEBUG断言就不会再使用
  - 再头文件**之前**添加`#define NDEBUG`





# GUI(仅概念)

## 事件（消息）驱动的程序设计

### 含义

- 每个应用程序都有一个消息队列
  - 系统把属于不同应用程序的消息放入各自的消息队列
  - 应用程序从自己的消息队列中获取消息并处理获得的消息
  - 直到取到某个特定消息（结束消息）后结束消息循环
    - 取消息处理消息的过程称为消息循环
- 应用程序的每个窗口都有一个消息处理函数
  - 消息大部分关联到某一个窗口
  - 应用程序取到消息后会调用相应窗口的消息处理函数

<img src="../leetcode/media/10-1-9.jpg" alt="10-1-9" style="zoom:33%;" />

## 文档-视结构的应用框架

- 应用框架是一种通用的可以复用的程序结构，规定了程序应该包含的组件及其关系，开发者通过给组件添加业务代码实现不同的应用。复用应用框架使得开发更快质量更高成本更低。
- 文档-视
  - 文档：用于存储和管理应用程序中的数据
  - 视：显示文档数据，实现对文档数据操作时与用户交互的功能
  - 实现了数据内部表示形式和外部展现形式相互独立
  - 一个文档可以对应多个视对象，即可以用不同方式显示和操作

## GUI

### 概念

- 含义：即图形用户接口，是人与计算机进行交互的一种方式，由窗口，下拉菜单，对话框的机制构成。用户通过鼠标键盘等发出指令，计算机用图形输出来反馈操作的结果。
- 优点：gui 比控制 台接口更为直观，便于用户进行操作，使得程序更为易用。



# 泛型（类属）程序设计

## 模板

### 概念

- 一个程序能对多种**类型**的数据进行操作或描述的特性称为类属或泛型
  - 类属函数：能对不同数据类型完成相同操作的函数
  - 类属类：成员类型可变，但操作类型不变
  - 对具有类属性的程序实体进行程序设计的技术为：泛型程序设计
- 传统通用指针（void*）实现的问题：
  - 麻烦，需要大量指针操作
  - 容易出错，编译程序无法进行类型检查
- 对自定类型操作时可能需要自定义拷贝构造函数和重载操作符
- 模板的复用：模板也属于一种多态，称为参数化多态。使用一个模板之前首先要对其实例化（用一个具体的类型去替代模板的类型参数），而实例化是在编译时刻进行的，它一定要见到相应的源代码，否则无法实例化！（所以要尽量要把模板的声明和实现都放在同一个头文件中）因此，模板属于源代码复用。

### 函数模板

- 只需要在函数定义（声明）前面添加：

  ```c++
  template<class T1,class T2,...[,int x]>//T1，T2均为类型名，可在函数参数等处使用,x为非类型参数
      //比如
  template <class T> 
  T max(T a, T b)
  { return a>b?a:b;
  }
  ```

- 实例化（模板实参推导）
  - 使用函数模板所定义的函数，首先必须要对函数模板进行实例化
  - 函数模板的实例化通常是隐式的（自动识别类型）
  - 有时，编译程序无法根据调用时的实参类型来确定所调用的模板实例函数如`max(int x,double y)`
    - 显式实例化如`max<double>(x,m); `
  - 如果使用了非类型参数，那么必须显示实例化如`f<int,10>(1); `

### 类模板

- 与函数模板类似

- ```c++
  template <class T1,class T2,...[,int x]> 
  class <类名>
  {	
      <类成员说明>//可以使用类型T1、T2
   public:
      <返回值> <函数名>(...);	
  }
  template <class T1,class T2,...[,int x]> 
  <返回值> <类名><T1,T2...[,int x]>::<函数名>(...);//类名后要实例化
  //类属类的操作依赖于类属函数实现
  
  template <class T, int size> //例
  class Stack
  {		T buffer[size];
  		int top;
  	public:
  		Stack() { top = -1; }
  		void push(const T &x);
  		void pop(T &x);
  };
  template <class T,int size> 
  void Stack <T,size>::push(const T &x) { ...... }
  template <class T, int size> 
  void Stack <T,size>::pop(T &x) { ...... }
  
  ```

- 类属类的实例化必须显示指出（比如vector使用时就要指定元素类型）

- 不同类模板实例之间不共享类模板中的静态成员（在同类型之间共享）。

- 友元

  - 普通函数做游元

  ```c++
  template <class T> //类模板A的定义
  class A
  { T x,y;
    ......
    friend void f(A<T>& a); //f是多个重载的函数，
  			     //它们与A的实例是一对一友元！
  };
  void f(A<int>& a) { ...... } //该f仅是A<int>的友元，
  void f(A<double>& a) { ...... } //该f仅是A<double>的友元
  ......
  A<int> a1; //实例化A<int>
  A<double> a2; //实例化A<double>
  A<char *> a3; //实例化A<char *>
  f(a1); //调用f(A<int>&)
  f(a2); //调用f(A<double>&)
  f(a3); //调用f(A<char *>&)，但连接时出错，该函数不存在！
  ```

  

  - 函数模板做友元

  ```c++
  template <class T> class A; //类模板A的声明（f的定义中要用到）
  template <class T> void f(A<T>& a) { ...... } //f是函数模板
  
  template <class T> //类模板A的定义
  class A
  { T x,y;
    ......
    template <class T1> friend void f(A<T1>& a); //整个模板f是友元，
  					//f的实例与A的实例是多对多友元
  };
  ......
  A<int> a1; //实例化A<int>
  A<double> a2; //实例化A<double>
  A<char *> a3; //实例化A<char *>
  f(a1); //实例化f<int>并调用之，它是A所有实例的友元
  f(a2); //实例化f<double>并调用之，它是A所有实例的友元
  f(a3); //实例化f<char *>并调用之，它是A所有实例的友元
  ```

  

## stl标准库

## 概念

- 容器：容器用于存储序列化的数据
- 算法：算法用于对容器中的数据元素进行一些常用操作
- 迭代器：迭代器实现了抽象的指针功能，它们指向容器中的数据元素，用于对容器中的数据元素进行遍历和访问。
  - 迭代器是容器和算法之间的桥梁：传给算法的不是容器，而是指向容器中元素的**迭代器**，算法通过迭代器实现对容器中数据元素的访问。这样使得算法与容器保持独立，从而提高算法的通用性。

## 容器

- 种类

  - vector:用于需要随机访问，并且主要在尾部增减元素的场景

  - list:用于经常在任意位置插入删除元素的场景

  - deque:用于需要随机访问并且需要在两端增减元素的场景

  - stack:用于仅在尾部增减访问的场景
  - queue:用于仅在尾部增加头部删除的场景
  - priority_queue:用于需要按照优先级排序出队的场景

  - map multimap unordered_map:用于需要根据关键字访问键值的场景，multiplemap可以有重复关键字，unordered_map是map的无序版本。
  - set multiset unordered_set:用于需要查找关键是否存在，multipleset可以有重复关键字，unordered_set是set的无序版本
  - basic_string:用于元素为字符类型，有string和wstring实例

- 如果容器的元素类型是一个类，则针对该类可能需要：自定义拷贝构造函数和赋值操作符重载函数以及重载小于操作符（<）

## 算法

- 一个算法能接收的迭代器的类型是通过算法模板参数的名字来体现的。

```c++
template <class InIt, class OutIt>
OutIt copy(InIt src_first, InIt src_last, 
                OutIt dst_first)
//src_first和src_last是输入迭代器，算法中只能读取它们指向的元素。
//dst_first是输出迭代器，算法中可以修改它指向的元素。
void sort(RanIt first, RanIt last);
```

- 有些算法可以让使用者提供一个函数或函数对象作为自定义操作，其参数和返回值类型由相应的算法决定。

  - Op或Fun：一元操作，需要一个参数

  - BinOp或BinFun：二元操作，需要两个参数

  - ```c++
    OutIt transform(InIt src_first, InIt src_last, 
                               OutIt dst_first, Op f);
    OutIt transform(InIt1 src_first1, InIt1 src_last1, 
                           InIt2 src_first2, OutIt dst_first, BinOp f);
    //可以为一维也可以为二维
    ```

## 迭代器

- 种类

  - 输出迭代器：可以修改指向的元素，支持* ++（输入输出是只得对于算法而言的）InIt
  - 输入迭代器：只能读取，支持* -> ++ == != OutIt
  - 前向迭代器：可以读取修改元素，支持* -> ++ == !=
  - 双向迭代器：可以读取修改元素，支持* -> ++ -- == !=
  - 随机访问迭代器：可以读取修改元素，支持* -> [] ++ -- + - += -= == != < <= > >=RanIt

  <img src="../leetcode/media/QQ截图20221201223206.png" alt="QQ截图20221201223206" style="zoom: 33%;" />

  - 反向迭代器：用于对容器元素从尾到头进行反向遍历：++操作是往容器首部移动，--操作是往容器尾部移动。
    - 可以通过容器类的成员函数rbegin和rend可以获得容器的尾和首元素的反向迭代器。
  - 插入迭代器用于在容器中指定位置插入元素，其中包括：
    - back_insert_iterator（用于在尾部插入元素）
    - front_insert_iterator（用于在首部插入元素）
    - insert_iterator（用于在任意指定位置插入元素）
    - 它们可以分别通过全局函数back_inserter、front_inserter和inserter来获得，函数的参数为容器。

- 与容器对应关系

  - vector deque basic_string 使用随即迭代器
  - list map set使用双向迭代器
  - queue stack priority_queue 不支持迭代器